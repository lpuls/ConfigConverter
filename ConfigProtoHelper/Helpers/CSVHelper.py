# _*_coding:utf-8_*_

import os
import csv
import xlwt
from Tools.FileHelper import load_excel
from SwapDatas.DataType import DataType


__TO_LUA_TEMPLATE__ = """
-- DO NOT MODIFY, This file is generated by tool.
local this = {{
{elements}
{extra}
{all}
}}
return this
"""


class CSVHelper:
    def __init__(self, path, config=None):
        if None is not config:
            self.__load_from_csv__(path, config)
        else:
            self.__load_from_excel__(path)

    def __load_from_csv__(self, path, config):
        """
        通过csv读取
        :param path: csv路径
        :param config: csv相关的配置文件
        """
        self.filed = list()
        self.type = list()
        self.swap_type = list()
        self.platform = list()
        self.note = list()
        self.order_index = None
        self.extra_index = list()
        self.data = list()

        # 从配置表中找出对应的数据
        self.name = os.path.basename(path)
        self.name = self.name.replace('.csv', '')
        module = config["DataTable"].get(self.name, None)
        if None is not module:
            self.target_name = module["TargetName"]
            self.module = module["Module"]
            self.order_index = module.get('order_key', None)

        # 读取csv
        self.__load_csv__(path)

        # 分析数据
        self.__process_origin_data__()
        self.__check_type_from_data__()

        self.extra_index = config['ExtraIndex'].get(self.name, self.extra_index)
        if "define" in self.filed:
            self.extra_index.append(self.filed.index("define"))
        if None is not self.order_index:
            self.order_index = self.filed.index(self.order_index)

    def __load_from_excel__(self, path):
        """
        通过excel读取
        :param path: excel路径
        """
        self.filed = list()
        self.type = list()
        self.swap_type = list()
        self.platform = list()
        self.note = list()
        self.order_index = None
        self.extra_index = list()
        self.define_index = None
        self.data = list()

        # 分析出文件名
        self.name = os.path.basename(path)
        self.name = self.name.replace(".xlsx", "")
        self.target_name = self.name

        # 分析模版
        index = self.name.find('module_')
        if -1 != index:
            self.module = self.name[: index] + "module"
        else:
            self.module = "default_module"
        self.target_name = self.target_name.replace(self.module + "_", "")

        self.__load_excel__(path)
        self.__check_type_from_data__()

        # 分析字段
        for item in self.filed:
            if -1 != item.upper().find("(EXTRA)"):
                self.extra_index.append(self.filed.index(item))

        if "sort_by_field_module" == self.module:
            for item in self.filed:
                if -1 != item.upper().find("(ORDER)"):
                    self.order_index = self.filed.index(item)
                    break
        elif "unique_module" == self.module:
            if "define" in self.filed:
                self.extra_index.append(self.filed.index("define"))

    def __check_type_from_data__(self):
        """
        根据数据分析对应DataType的类型
        :return:
        """
        data = self.data[0]
        for index in range(0, len(data)):
            if 'int' == self.type[index]:
                self.swap_type.append(DataType(DataType.INT_TYPE))
            elif 'varchar' == self.type[index]:
                if '{' == data[index][0]:
                    self.swap_type.append(DataType(DataType.ARRAY_TYPE))
                else:
                    self.swap_type.append(DataType(DataType.STR_TYPE))

    def __process_origin_data__(self):
        """
        处理原始数据
        :return:
        """
        for item in self.data[0]:
            self.filed.append(item)
        for item in self.data[1]:
            self.type.append(item)
        for item in self.data[2]:
            self.platform.append(item)
        for item in self.data[3]:
            self.note.append(item)
        del self.data[0]
        del self.data[0]
        del self.data[0]
        del self.data[0]

    def __load_csv__(self, path):
        """
        从csv中加载数据
        :param path: csv路径
        """
        csv_file = csv.reader(open(path, 'r', encoding='utf8'))
        for item in csv_file:
            temp = list()
            self.data.append(temp)
            for data in item:
                temp.append(data)

    def __load_excel__(self, path):
        def analyze_sheet(_, sheet):
            if sheet.nrows < 3:
                print("无效的表置表格式")
                return None

            # 获取基本属性
            self.type = sheet.row_values(0)
            self.note = sheet.row_values(1)
            self.filed = sheet.row_values(2)
            self.platform = sheet.row_values(3)

            for row_index in range(4, sheet.nrows):
                # data = list()
                # for col_index in range(0, sheet.ncols):
                #     data.append(sheet.cell(row_index, col_index).value)
                self.data.append(sheet.row_values(row_index))

        load_excel(path, analyze_sheet)

    @staticmethod
    def __write_to_execl_by_index__(row, table, data_list):
        for index in range(0, len(data_list)):
            table.write(row, index, data_list[index])

    def __extra_index__(self, id_index):
        """
        根据extral表生成以extral表中记录的字段对应的ID列表
        :param id_index: id的列号
        :return: 对应的lua字符串
        """

        extra_index = self.extra_index
        index_value = dict()
        for data in self.data:
            # 遍历所有需要处理的字段下标
            for index in extra_index:
                extra_index_dict = index_value.get(index, dict())
                index_value[index] = extra_index_dict

                value = data[index]
                extra_list = extra_index_dict.get(value, list())
                extra_index_dict[value] = extra_list
                extra_list.append(data[id_index])

        # 转成列表
        result = ""
        for index, id_to_value_list in index_value.items():
            filed = self.filed[index]
            main_type = self.swap_type[index].main_type
            context = "\tget_id_list_by_{0} = {{\n{1}\n\t}},\n"
            element = ""
            for key, value in id_to_value_list.items():
                if DataType.STR_TYPE == main_type:
                    element += "\t\t{0} = {1},\n".format(key, value[0])
                else:
                    element += "\t\t[{0}] = {{{1}}},\n".format(key, value[1: len(value) - 1])
            result += context.format(filed, element)
        return result

    def __spawn_element_format__(self):
        """
        根据表结构生成格式
        :return: 格式字符串
        """
        index = 0
        element = ""
        for item in self.filed:
            if -1 != self.platform[index].find('c'):
                if DataType.STR_TYPE == self.swap_type[index].main_type:
                    element += "\t\t{{{0}}} = \"{{{1}}}\",\n".format(item, item + "_value")
                else:
                    element += "\t\t{{{0}}} = {{{1}}},\n".format(item, item + "_value")
            index += 1
        return """\t[{{index}}] = {{{{\n{0}\n\t}}}},\n""".format(element)

    def __process_default__(self, id_index):
        """
        处理默认模版表
        :param id_index: id 的列号
        :return: 导出成lua的内容， all表的内容
        """
        all_id = list()
        element = self.__spawn_element_format__()

        result = ""
        for data in self.data:
            filed_to_value = dict()
            filed_to_value["index"] = data[id_index]
            all_id.append(int(data[id_index]))
            for index in range(0, len(self.filed)):
                if -1 == self.platform[index].find('c'):
                    continue
                filed_to_value[self.filed[index]] = self.filed[index]
                filed_to_value[self.filed[index] + "_value"] = data[index]
            result += element.format_map(filed_to_value)
        str_all = str(all_id)
        return result, "\tall = {{{0}}},".format(str_all[1: len(str_all) - 1])

    def __process_sort__(self, id_index):
        """
        处理排序模版表
        :param id_index: id 的列号
        :return: 导出成lua的内容， all表的内容
        """
        element = self.__spawn_element_format__()

        result = ""
        all_id = [None] * len(self.data)
        for data in self.data:
            filed_to_value = dict()
            filed_to_value["index"] = data[id_index]
            all_id[int(data[self.order_index]) - 1] = int(data[id_index])
            for index in range(0, len(self.filed)):
                if -1 == self.platform[index].find('c'):
                    continue
                filed_to_value[self.filed[index]] = self.filed[index]
                filed_to_value[self.filed[index] + "_value"] = data[index]
            result += element.format_map(filed_to_value)
        str_all = str(all_id)
        return result, "\tall = {{{0}}},".format(str_all[1: len(str_all) - 1])

    def __process_unique__(self, id_index):
        """
        处理唯一ID模版表
        :param id_index: id 的列号
        :return: 导出成lua的内容， all表的内容
        """
        return self.__process_default__(id_index)

    def __process_word__(self):
        """
        处理字词模版表
        :return: 导出成lua的内容，空字符串
        """
        root = dict()

        def build_word_tree(tree, word):
            for w in word:
                leaf = tree.get(w, dict())
                tree[w] = leaf
                tree = leaf
            tree["result"] = "true"

        for data in self.data:
            build_word_tree(root, data[0])

        def tree_to_lua(key, tree, deep):
            space = "\t" * deep
            if not isinstance(tree, dict):
                return "\n{2}{0} = {1},\n".format(key, tree, space)

            context = "\n{1}[\"{0}\"] = {{".format(key, space)
            for k, v in tree.items():
                context += tree_to_lua(k, v, deep + 1)
            context += space + "},\n"
            return context

        lua_context = ""
        for leaf_key, leaf_value in root.items():
            lua_context += tree_to_lua(leaf_key, leaf_value, 1)
        return lua_context, ""

    def to_excel(self, path):
        """
        将csv转成excel
        :param path: 导出路径
        :return:
        """
        file = xlwt.Workbook()
        table = file.add_sheet('sheet 1')

        # 将原本各种模版需要的数据以标记的方式写入字段名中
        if "sort_by_field_module" == self.module and None is not self.order_index and -1 != self.order_index:
            self.filed[self.order_index] += "(ORDER)"
        for extra_index in self.extra_index:
            self.filed[extra_index] += "(EXTRA)"

        # 写入类型
        CSVHelper.__write_to_execl_by_index__(0, table, self.type)

        # 写入说明
        CSVHelper.__write_to_execl_by_index__(1, table, self.note)

        # 写入字段名
        CSVHelper.__write_to_execl_by_index__(2, table, self.filed)

        # 写入导出平台
        CSVHelper.__write_to_execl_by_index__(3, table, self.platform)

        # 写入数据
        for row in range(0, len(self.data)):
            CSVHelper.__write_to_execl_by_index__(4 + row, table, self.data[row])

        file.save(path + self.module + "_" + self.target_name + ".xlsx")

    def to_lua(self, path):
        """
        导出成lua代码
        :param path: 导出路径
        :return:
        """
        # 找到id所在的列
        id_index = None
        if 'id' in self.filed:
            id_index = self.filed.index("id")

        if "unique_module" == self.module:
            assert None is not id_index, "找不到id"
            result, all_id = self.__process_default__(id_index)
        elif "sort_by_field_module" == self.module:
            assert None is not id_index, "找不到id"
            assert None is not self.order_index and -1 != self.order_index, "找不到排序字段"
            result, all_id = self.__process_sort__(id_index)
        elif "word_module" == self.module:
            result, all_id = self.__process_word__()
        else:
            assert None is not id_index, "找不到id"
            result, all_id = self.__process_default__(id_index)

        extra = self.__extra_index__(id_index)
        context = __TO_LUA_TEMPLATE__.format_map({
            "elements": result,
            "extra": extra,
            "all": all_id
        })
        with open(path + self.target_name + ".lua", 'w', encoding='utf8') as f:
            f.write(context)


